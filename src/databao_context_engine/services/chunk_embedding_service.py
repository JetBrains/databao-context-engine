import logging
from enum import Enum
from typing import cast

import databao_context_engine.perf.core as perf
from databao_context_engine.llm.descriptions.provider import DescriptionProvider
from databao_context_engine.llm.embeddings.provider import EmbeddingProvider
from databao_context_engine.pluginlib.build_plugin import EmbeddableChunk
from databao_context_engine.serialization.yaml import to_yaml_string
from databao_context_engine.services.embedding_shard_resolver import EmbeddingShardResolver
from databao_context_engine.services.models import ChunkEmbedding
from databao_context_engine.services.persistence_service import PersistenceService

logger = logging.getLogger(__name__)


class ChunkEmbeddingMode(Enum):
    """Mode controlling how chunks are embedded."""

    EMBEDDABLE_TEXT_ONLY = "EMBEDDABLE_TEXT_ONLY"
    """
    The embedding is generated only from the string defined by the plugin as embeddable for a chunk.
    """

    GENERATED_DESCRIPTION_ONLY = "GENERATED_DESCRIPTION_ONLY"
    """
    The embedding is generated only from a description of the chunk generated by a LLM.
    """

    EMBEDDABLE_TEXT_AND_GENERATED_DESCRIPTION = "EMBEDDABLE_TEXT_AND_GENERATED_DESCRIPTION"
    """
    The embedding is generated from both the embeddable string of the chunk and the description of the chunk generated by a LLM.
    """

    def should_generate_description(self) -> bool:
        return self in (
            ChunkEmbeddingMode.GENERATED_DESCRIPTION_ONLY,
            ChunkEmbeddingMode.EMBEDDABLE_TEXT_AND_GENERATED_DESCRIPTION,
        )


class ChunkEmbeddingService:
    def __init__(
        self,
        *,
        persistence_service: PersistenceService,
        embedding_provider: EmbeddingProvider,
        description_provider: DescriptionProvider | None,
        shard_resolver: EmbeddingShardResolver,
        chunk_embedding_mode: ChunkEmbeddingMode = ChunkEmbeddingMode.EMBEDDABLE_TEXT_ONLY,
    ):
        self._persistence_service = persistence_service
        self._embedding_provider = embedding_provider
        self._description_provider = description_provider
        self._shard_resolver = shard_resolver
        self._chunk_embedding_mode = chunk_embedding_mode

        if self._chunk_embedding_mode.should_generate_description() and description_provider is None:
            raise ValueError("A DescriptionProvider must be provided when generating descriptions")

    def embed_chunks(
        self, *, chunks: list[EmbeddableChunk], result: str, full_type: str, datasource_id: str, override: bool = False
    ) -> None:
        """Turn plugin chunks into persisted chunks and embeddings.

        Flow:
        1) Embed each chunk into an embedded vector.
        2) Get or create embedding table for the appropriate model and embedding dimensions.
        3) Persist chunks and embeddings vectors in a single transaction.
        """
        if not chunks:
            return

        logger.debug(
            f"Embedding {len(chunks)} chunks for datasource {datasource_id}, with chunk_embedding_mode={self._chunk_embedding_mode}"
        )

        chunk_display_texts: list[str] = [
            (chunk.content if isinstance(chunk.content, str) else to_yaml_string(chunk.content)) for chunk in chunks
        ]

        if self._chunk_embedding_mode.should_generate_description():
            embedding_texts, generated_descriptions = self._prepare_embedding_texts_with_descriptions(
                chunks=chunks,
                chunk_display_texts=chunk_display_texts,
                context=result,
            )
        else:
            embedding_texts = [chunk.embeddable_text for chunk in chunks]
            generated_descriptions = [""] * len(chunks)

        vecs = self._embed_many(embedding_texts)

        enriched_embeddings: list[ChunkEmbedding] = [
            ChunkEmbedding(
                chunk=chunk,
                vec=vec,
                display_text=display_text,
                generated_description=gen_desc,
            )
            for chunk, vec, display_text, gen_desc in zip(chunks, vecs, chunk_display_texts, generated_descriptions)
        ]

        table_name = self._shard_resolver.resolve_or_create(
            embedder=self._embedding_provider.embedder,
            model_id=self._embedding_provider.model_id,
            dim=self._embedding_provider.dim,
        )

        self._persistence_service.write_chunks_and_embeddings(
            chunk_embeddings=enriched_embeddings,
            table_name=table_name,
            full_type=full_type,
            datasource_id=datasource_id,
            override=override,
        )

    @perf.perf_span("description.generate")
    def _prepare_embedding_texts_with_descriptions(
        self,
        *,
        chunks: list[EmbeddableChunk],
        chunk_display_texts: list[str],
        context: str,
    ) -> tuple[list[str], list[str]]:
        embedding_texts: list[str] = []
        generated_descriptions: list[str] = []

        for chunk, display_text in zip(chunks, chunk_display_texts):
            generated_description = cast(DescriptionProvider, self._description_provider).describe(
                text=display_text,
                context=context,
            )
            generated_descriptions.append(generated_description)

            if self._chunk_embedding_mode == ChunkEmbeddingMode.GENERATED_DESCRIPTION_ONLY:
                embedding_texts.append(generated_description)
            elif self._chunk_embedding_mode == ChunkEmbeddingMode.EMBEDDABLE_TEXT_AND_GENERATED_DESCRIPTION:
                embedding_texts.append(generated_description + "\n" + chunk.embeddable_text)

        return embedding_texts, generated_descriptions

    @perf.perf_span("embedding.embed_many")
    def _embed_many(self, embedding_texts: list[str]) -> list[list[float]]:
        return self._embedding_provider.embed_many(embedding_texts)
